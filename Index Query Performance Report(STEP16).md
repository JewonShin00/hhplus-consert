### **STEP 16_심화**

#### **1. 트랜잭션 범위와 서비스 분리**
- **현재 트랜잭션 범위**: 현재 콘서트 예약 기능은 한 개의 서비스에서 **트랜잭션을 관리**하고 있으며, 예약, 취소, 조회 등의 기능이 모두 같은 트랜잭션 내에서 처리됩니다.
- **서비스 규모 확장 시 고려사항**:
  - **서비스 분리 방안**: 서비스가 확장됨에 따라 **예약 서비스**, **결제 서비스**, **알림 서비스** 등을 분리해야 할 필요가 있습니다. 이때, 각 서비스 간의 **트랜잭션 일관성**을 보장하기 위해서는 **분산 트랜잭션** 또는 **사가 패턴**과 같은 트랜잭션 관리 기법을 고려해야 합니다.
  - **트랜잭션 처리의 한계**: 트랜잭션을 서비스 단위로 분리할 경우, 각 서비스 간의 트랜잭션 처리에 있어 일관성을 유지하는 것이 어려울 수 있습니다. 이를 해결하기 위해 **이벤트 기반의 비동기 처리**를 활용하여 각 서비스 간의 의존성을 낮추고, 일관성을 유지할 수 있는 방법을 고려할 수 있습니다.

#### **2. 분산 트랜잭션 환경에서 발생할 수 있는 현상**
- **데이터 일관성 문제**: 각 서비스가 독립적으로 트랜잭션을 처리하면서, 네트워크 지연이나 장애로 인해 데이터가 불일치하게 되는 상황이 발생할 수 있습니다. 예를 들어, 결제는 완료되었지만 예약이 정상적으로 반영되지 않는 경우가 있을 수 있습니다.
- **이중 업데이트 문제**: 동일한 이벤트가 여러 서비스에 전달되면서 데이터가 중복 저장되거나, 상태가 엇갈리는 문제가 발생할 수 있습니다.
- **서비스 간 결합도 증가**: 분산 환경에서 각 서비스가 서로 트랜잭션 상태를 공유하려고 할 때 결합도가 증가하게 되며, 이는 시스템 복잡도를 높이고 유지보수를 어렵게 만듭니다.

#### **3. 분산 트랜잭션 해결 방안**
- **사가 패턴**: 사가 패턴을 사용하여 각 서비스가 로컬 트랜잭션을 독립적으로 관리하고, 실패 시 보상 작업을 수행하는 방식으로 전체 트랜잭션을 관리할 수 있습니다. 이를 통해 중앙 집중식 트랜잭션 관리의 필요성을 줄이고, 각 서비스의 자율성을 높일 수 있습니다.
- **이벤트 기반 아키텍처**: **이벤트 브로커(Kafka 등)**를 활용하여 각 서비스 간의 통신을 비동기 방식으로 처리하고, 트랜잭션 상태를 이벤트로 관리하는 방식입니다. 이는 서비스 간의 결합도를 낮추고, 시스템의 유연성을 증가시킵니다.
- **CQRS 및 이벤트 소싱**: **CQRS**(Command Query Responsibility Segregation)와 **이벤트 소싱**을 함께 적용하여 상태 변경을 이벤트로 기록하고, 이를 통해 데이터의 일관성을 유지할 수 있습니다. 이를 통해 시스템의 확장성 및 장애 복구를 보다 효과적으로 관리할 수 있습니다.

#### **4. 실시간 주문 및 이력 데이터 저장**
- **실시간 좌석 예약 데이터 전달**: 실시간 좌석 예약 정보를 외부 데이터 플랫폼에 전달하거나, 메시지 큐(Kafka 등)를 활용해 다른 서비스와 데이터를 주고받는 방안을 고려할 수 있습니다.
  - **메시지 큐 사용**: 예약이 완료될 때마다 **메시지 큐**를 통해 이 정보를 **이력 저장 서비스**로 전달하는 구조를 도입하여 기존 로직에 영향을 주지 않고 부가 기능을 확장할 수 있습니다.
- **이력 데이터 저장**: 예약 및 취소와 같은 주요 이벤트에 대한 **이력 데이터를 저장**함으로써, 사용자에게 예약 내역 조회 서비스를 제공하거나, 관리자에게 분석 자료로 활용될 수 있도록 할 수 있습니다.
